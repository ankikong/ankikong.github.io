<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ankikong.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="c++学习日志">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp">
<meta property="og:url" content="https://ankikong.github.io/c/index.html">
<meta property="og:site_name" content="ankikong">
<meta property="og:description" content="c++学习日志">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-01-18T15:53:24.000Z">
<meta property="article:modified_time" content="2025-07-13T12:19:37.724Z">
<meta property="article:author" content="ankikong">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="programming">
<meta property="article:tag" content="network">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ankikong.github.io/c/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ankikong.github.io/c/","path":"c/","title":"cpp"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>cpp | ankikong</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-NR7TLCQ044"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-NR7TLCQ044","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>



  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{&quot;token&quot;: &quot;fd9b08448ffd4bf4b246479d7da6f3ca&quot;}'></script>





  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ankikong</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11"><span class="nav-number">1.</span> <span class="nav-text">C++11</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-14"><span class="nav-number">2.</span> <span class="nav-text">C++14</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-%E5%92%8C-malloc"><span class="nav-number">3.</span> <span class="nav-text">new 和 malloc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#allocator"><span class="nav-number">3.1.</span> <span class="nav-text">allocator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-number">4.1.</span> <span class="nav-text">虚函数表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">5.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-select-poll"><span class="nav-number">6.</span> <span class="nav-text">epoll,select,poll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pthread-h"><span class="nav-number">7.</span> <span class="nav-text">pthread.h</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fork"><span class="nav-number">8.</span> <span class="nav-text">fork</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#atomic"><span class="nav-number">9.</span> <span class="nav-text">atomic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile"><span class="nav-number">10.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#restrict"><span class="nav-number">11.</span> <span class="nav-text">restrict</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mutable"><span class="nav-number">12.</span> <span class="nav-text">mutable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#explicit"><span class="nav-number">13.</span> <span class="nav-text">explicit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E5%92%8Ctemplate"><span class="nav-number">14.</span> <span class="nav-text">类型推断和template</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F-%E8%AE%BF%E9%97%AE%E6%80%A7"><span class="nav-number">15.</span> <span class="nav-text">存储方式&amp;访问性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute"><span class="nav-number">16.</span> <span class="nav-text">attribute</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-number">17.</span> <span class="nav-text">预处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">18.</span> <span class="nav-text">拷贝构造函数和赋值运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E8%BD%AC%E7%A7%BB%E8%AF%AD%E4%B9%89"><span class="nav-number">19.</span> <span class="nav-text">右值引用和转移语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">20.</span> <span class="nav-text">条件变量</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ankikong</p>
  <div class="site-description" itemprop="description">ankikong's blog</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ankikong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ankikong" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ankikong.github.io/c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ankikong">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ankikong">
      <meta itemprop="description" content="ankikong's blog">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="cpp | ankikong">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          cpp
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-18 23:53:24" itemprop="dateCreated datePublished" datetime="2020-01-18T23:53:24+08:00">2020-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-13 20:19:37" itemprop="dateModified" datetime="2025-07-13T20:19:37+08:00">2025-07-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>c++学习日志</p>
<span id="more"></span>

<h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><ol>
<li><p>基于范围的<code>for</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (type a:container) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>自动类型推断auto</code></p>
</li>
<li><p>Lambda</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// capture: 获取上文对应变量,[=]:捕获上文所有变量</span></span><br><span class="line"><span class="comment">// params: 参数</span></span><br><span class="line">[capture](params)&#123;body&#125;</span><br><span class="line"><span class="comment">// 如:</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>, b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">auto</span> aa=[a, &amp;b](<span class="type">int</span> c)&#123;</span><br><span class="line">    b=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后置返回类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)</span> -&gt; <span class="title">decltype</span><span class="params">(a+b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>final</code>, <code>override</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">final</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">sum2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PP</span>: <span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nullptr</code></p>
</li>
<li><p><code>long long</code></p>
</li>
<li><p>线程</p>
</li>
<li><p><code>tuple</code></p>
</li>
<li><p>智能指针</p>
</li>
<li><p>条件变量</p>
</li>
</ol>
<h2 id="C-14"><a href="#C-14" class="headerlink" title="C++14"></a>C++14</h2><ol>
<li>Lambda:参数支持auto</li>
</ol>
<h2 id="new-和-malloc"><a href="#new-和-malloc" class="headerlink" title="new 和 malloc"></a>new 和 malloc</h2><ol>
<li><p>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。特别的，new甚至可以不为对象分配内存！<strong>定位new</strong>的功能可以办到这一点</p>
<ul>
<li>定位new就是相当于给一个引用一个已有的内存空间，但是可以设置新的类型，共享同一块空间</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>(address) type;</span><br><span class="line"><span class="keyword">new</span>(address) <span class="built_in">type</span>(initializers);</span><br><span class="line"><span class="keyword">new</span>(address) type[size];</span><br><span class="line"><span class="keyword">new</span>(address) type[size]&#123;braced initializer list&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> *b=<span class="built_in">new</span>(&amp;a) <span class="type">char</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void *, 需要通过强制类型转换将void*指针转换成我们需要的类型。</p>
</li>
<li><p>new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</p>
</li>
<li><p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</p>
</li>
<li><p>是否调用构造函数&#x2F;析构函数</p>
<ul>
<li><p>使用new操作符来分配对象内存时会经历三个步骤：</p>
<ul>
<li>第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</li>
<li>第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。</li>
<li>第三部：对象构造完成后，返回一个指向该对象的指针。</li>
</ul>
</li>
<li><p>使用delete操作符来释放对象内存时会经历两个步骤：</p>
<ul>
<li>第一步：调用对象的析构函数。</li>
<li>第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。</li>
</ul>
</li>
<li><p>总之来说，new&#x2F;delete会调用对象的构造函数&#x2F;析构函数以完成对象的构造&#x2F;析构。而malloc则不会</p>
</li>
</ul>
</li>
<li><p>C++提供了new[] 与delete[]来专门处理数组类型;至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小</p>
</li>
<li><p>operator new &#x2F;operator delete的实现<strong>可以</strong>基于malloc，而malloc的实现不可以去调用new。</p>
</li>
<li><p>opeartor new &#x2F;operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本</p>
</li>
<li><p>new无法更改已分配内存的大小，而malloc申请的内存可以通过realloc调整</p>
</li>
</ol>
<h3 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h3><p>在g++中实现的allocator,是用new和相关函数进行封装的</p>
<p>SGI STL的allocator是自行实现的，内存分配分为2个阶段：第一是在8B-128B的16个链表中寻找合适的内存，如果找不到，就到内存池拿，如果内存池不够，就使用malloc申请内存，补充内存池；第二是大于128B的，直接使用malloc</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>以下取自维基百科：<br>在面向对象程序设计中，派生类继承自基类。使用指针或引用访问派生类对象时，指针或引用本身所指向的类型可以是基类而不是派生类。如果派生类覆盖了基类中的方法，通过上述指针或引用调用该方法时，可以有两种结果：</p>
<ol>
<li>调用到<strong>基类</strong>的方法：编译器根据指针或引用的类型决定，称作“早绑定”；</li>
<li>调用到<strong>派生类</strong>的方法：语言的运行时系统根据对象的实际类型决定，称作“迟绑定”。<br><strong>虚函数的效果属于后者</strong>。如果问题中基类的函数是“虚”的，则调用到的都是最终派生类（英语：most-derived class）中的函数实现，与指针或引用的类型无关。反之，如果函数非“虚”，调用到的函数就在编译期根据指针或者引用所指向的类型决定。</li>
</ol>
<p>有了虚函数，程序甚至能够调用编译期还不存在的函数。</p>
<p>在 C++ 中，在基类的成员函数声明前加上关键字 <code>virtual</code> 即可让该函数成为<strong>虚函数</strong>，派生类中对此函数的不同实现都会继承这一修饰符，允许后续派生类覆盖，达到迟绑定的效果。即便是基类中的成员函数调用虚函数，也会调用到派生类中的版本。</p>
<p>实现：虚函数表和虚表指针</p>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>虚函数表,每个含有虚函数的类都含有一份,同一类的实例共享同一份虚函数表,虚函数表位于类的最前面.虚函数表按声明顺序保存着类的所有虚函数指针.<strong>多重继承中,虚函数表的顺序按继承顺序保存</strong>。<br>对象的大小：取决于继承了几个类。无虚函数的空类，大小是1。含有虚函数，大小是一个指针。继承了含有虚函数的父类，大小是继承数量*指针大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Func)</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A aa;</span><br><span class="line">    ll** tab=(ll**)&amp;aa;</span><br><span class="line">    Func fa = (Func)tab[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    Func fb = (Func)tab[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">fa</span>(); <span class="built_in">fb</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>纯虚函数：virtual int say() &#x3D; 0;相当于抽象函数</p>
<p>虚继承：多重继承中，共用共同父类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">an</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">111</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">say2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">222</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bn</span> : an &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">11111</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">22222</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    bn *bb = <span class="keyword">new</span> <span class="built_in">bn</span>();</span><br><span class="line">    an *aa = (an*)bb;</span><br><span class="line">    bb-&gt;<span class="built_in">say1</span>();</span><br><span class="line">    bb-&gt;<span class="built_in">say2</span>();</span><br><span class="line">    aa-&gt;<span class="built_in">say1</span>();</span><br><span class="line">    aa-&gt;<span class="built_in">say2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出为</span></span><br><span class="line"><span class="comment">// 11111</span></span><br><span class="line"><span class="comment">// 22222</span></span><br><span class="line"><span class="comment">// 111       非虚函数，调用基类方法</span></span><br><span class="line"><span class="comment">// 22222     虚函数，调用派生类方法</span></span><br></pre></td></tr></table></figure>

<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存</p>
<p><code>unique_ptr</code>和<code>auto_ptr</code>类似,但是<code>auto_ptr</code>在c++11中被替换为<code>unique_ptr</code>,且<code>unique_ptr</code>不允许在局部赋值<br><code>unique_ptr</code>在任何时候只能有一个指向内存,可以使用move转移所有权<br><code>share_ptr</code>可以同时有多个智能指针指向内存<br><code>weak_ptr</code>是弱引用,在使用前需要申请转为<code>share_ptr</code>,<br><code>share_ptr</code>允许多个引用</p>
<p>当 <code>shared_ref_cnt</code> 被减为0时，自动释放 <code>ptr</code> 指针所指向的对象。当 <code>shared_ref_cnt</code> 与 <code>weak_ref_cnt</code> 都变成0时，才释放 <code>ptr_manage</code> 对象。<br>如此以来，只要有相关联的 <code>shared_ptr</code> 存在，对象就存在。<code>weak_ptr</code> 不影响对象的生命周期。当用 <code>weak_ptr</code> 访问对象时，对象有可能已被释放了，要先 <code>lock()</code>。</p>
<h2 id="epoll-select-poll"><a href="#epoll-select-poll" class="headerlink" title="epoll,select,poll"></a>epoll,select,poll</h2><p>阻塞方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请socket</span></span><br><span class="line"><span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sock==<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create socket failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">sockaddr_in ser;</span><br><span class="line"><span class="built_in">memset</span>(&amp;ser, <span class="number">0</span>, <span class="built_in">sizeof</span>(ser));</span><br><span class="line">ser.sin_port = <span class="built_in">htons</span>(<span class="number">55555</span>);</span><br><span class="line">ser.sin_family=AF_INET;</span><br><span class="line">ser.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"><span class="comment">// 绑定端口</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(sock, (sockaddr*)&amp;ser, <span class="built_in">sizeof</span>(ser))==<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bind failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开启监听</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">listen</span>(sock, <span class="number">1</span>)==<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listen failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> conn;</span><br><span class="line">sockaddr_in client;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 开始接受请求</span></span><br><span class="line">    <span class="keyword">if</span> ((conn=<span class="built_in">accept</span>(sock, (sockaddr*)&amp;client, &amp;len))==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="keyword">while</span> ((n = <span class="built_in">recv</span>(conn, buff, <span class="number">1024</span>, <span class="number">0</span>))!=<span class="number">-1</span>) &#123;</span><br><span class="line">        buff[n]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv from %d,%d,len:%d: %s&quot;</span>, (<span class="type">int</span>)client.sin_addr.s_addr, (<span class="type">int</span>)client.sin_port, n, buff);</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="built_in">send</span>(conn, buff, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;exit\r\n&quot;</span>, buff)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(conn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(sock);</span><br></pre></td></tr></table></figure>

<p>select:</p>
<ol>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li>
<li>select支持的文件描述符数量太小了，默认是1024</li>
<li>返回值<br>- &lt;0 select错误<br>- 0 等待超时<br>- &gt;0 有可操作文件描述符</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line"><span class="built_in">bind</span>(s, ...);</span><br><span class="line"><span class="built_in">listen</span>(s, ...);</span><br><span class="line"><span class="type">int</span> fds[] =  存放需要监听的socket;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">select</span>(..., fds, ...)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; fds.count; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(fds[i], ...))&#123;</span><br><span class="line">            <span class="comment">//fds[i]的数据处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>epoll</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* epoll_event.events:</span></span><br><span class="line"><span class="comment">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</span></span><br><span class="line"><span class="comment">EPOLLOUT：表示对应的文件描述符可以写</span></span><br><span class="line"><span class="comment">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</span></span><br><span class="line"><span class="comment">EPOLLERR：表示对应的文件描述符发生错误</span></span><br><span class="line"><span class="comment">EPOLLHUP：表示对应的文件描述符被挂断</span></span><br><span class="line"><span class="comment">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的</span></span><br><span class="line"><span class="comment">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里,LT模式是默认模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sock==<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create socket failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">sockaddr_in ser;</span><br><span class="line"><span class="built_in">memset</span>(&amp;ser, <span class="number">0</span>, <span class="built_in">sizeof</span>(ser));</span><br><span class="line">ser.sin_port = <span class="built_in">htons</span>(<span class="number">55555</span>);</span><br><span class="line">ser.sin_family=AF_INET;</span><br><span class="line">ser.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"><span class="type">int</span> flag = <span class="built_in">fcntl</span>(sock, F_GETFL, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 设置非阻塞</span></span><br><span class="line"><span class="built_in">fcntl</span>(sock, F_SETFL, flag | O_NONBLOCK);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(sock, (sockaddr*)&amp;ser, <span class="built_in">sizeof</span>(ser))==<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bind failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">listen</span>(sock, maxCnt)==<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listen failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建epoll</span></span><br><span class="line"><span class="type">int</span> ep = <span class="built_in">epoll_create</span>(maxCnt);</span><br><span class="line"><span class="keyword">if</span> (ep==<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create epool failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">epoll_event eeve;</span><br><span class="line">eeve.data.fd = sock;</span><br><span class="line">eeve.events = EPOLLIN;</span><br><span class="line"><span class="type">int</span> clRet = <span class="built_in">epoll_ctl</span>(ep, EPOLL_CTL_ADD, sock, &amp;eeve);</span><br><span class="line"><span class="keyword">if</span> (clRet==<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;epoll_ctl failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">auto</span> events = <span class="keyword">new</span> epoll_event[maxCnt];</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    clRet = <span class="built_in">epoll_wait</span>(ep, events, maxCnt, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;clRet; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> nw = events[i];</span><br><span class="line">        <span class="keyword">if</span> (sock==nw.data.fd &amp;&amp; (EPOLLIN==(nw.events&amp;EPOLLIN))) &#123;</span><br><span class="line">            <span class="type">int</span> newConn = <span class="built_in">accept</span>(sock, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (newConn==<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;accept new connection failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            epoll_event *newEv=<span class="keyword">new</span> <span class="built_in">epoll_event</span>();</span><br><span class="line">            newEv-&gt;events = EPOLLIN;</span><br><span class="line">            newEv-&gt;data.fd = newConn;</span><br><span class="line">            <span class="type">int</span> res = <span class="built_in">epoll_ctl</span>(ep, EPOLL_CTL_ADD, newConn, newEv);</span><br><span class="line">            <span class="keyword">if</span> (res==<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> newEv;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;add new connection to epoll failed\n&quot;</span>);</span><br><span class="line">                <span class="built_in">close</span>(newConn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nw.events==(nw.events|EPOLLIN)) &#123;</span><br><span class="line">            <span class="type">int</span> len=<span class="built_in">recv</span>(nw.data.fd, buff, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (len&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> tmpFd = nw.data.fd;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(ep, EPOLL_CTL_DEL, tmpFd, &amp;nw);</span><br><span class="line">                <span class="built_in">close</span>(tmpFd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buff[len]=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recv from:%s&quot;</span>, buff);</span><br><span class="line">                <span class="built_in">send</span>(nw.data.fd, buff, len, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;exit\r\n&quot;</span>, buff)==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(ep, EPOLL_CTL_DEL, nw.data.fd, &amp;nw);</span><br><span class="line">                    <span class="built_in">close</span>(nw.data.fd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nw.events==(nw.events|EPOLLERR)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;found error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">epoll_ctl</span>(ep, EPOLL_CTL_DEL, nw.data.fd, &amp;nw);</span><br><span class="line">            <span class="built_in">close</span>(nw.data.fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(sock);</span><br><span class="line"><span class="built_in">close</span>(ep);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="pthread-h"><a href="#pthread-h" class="headerlink" title="pthread.h"></a>pthread.h</h2><p><code>pthread_create(pthread_t *pId, pthread_attr_t *attr, void *(*func)(void *), void *args)</code><br>创建线程并运行<br><code>pId</code>: 线程唯一id<br><code>attr</code>：线程相关属性<br><code>func</code>：线程入口<br><code>args</code>: 线程入口参数</p>
<p><code>pthread_exit(void* rs)</code><br>在线程内使用，退出线程<br><code>rs</code>: 线程返回数据</p>
<p><code>pthread_join(pthread_t pId, void** rs)</code><br>等待线程<br><code>pId</code>：线程id<br><code>rs</code>：pthread_exit(rs),捕获返回值</p>
<p><code>pthread_attr_t attr</code>;&#x2F;&#x2F;声明一个参数<br><code>pthread_attr_init(&amp;attr)</code>;&#x2F;&#x2F;对参数进行初始化<br><code>pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE)</code>;&#x2F;&#x2F;设置线程为可连接的<br><code>pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED)</code>;&#x2F;&#x2F;设置线程为可分离的<br><code>pthread_attr_destroy(&amp;attr)</code>&#x2F;&#x2F;销毁属性，防止内存泄漏</p>
<p><code>int pthread_detach(pthread_t tid)</code>;<br>detached的线程在结束的时候会自动释放线程所占用的资源</p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>成功时返回两个值，子进程返回0，父进程返回子进程标记<br>个进程通过调用fork函数，创建一个新进程。新进程成为子进程(child process)<br>通过判断fork返回值，是0还是非0（非-1），即可控制让父子进程做不同的事情<br>fork会复制所有资源(写时复制)<br>vfork不会复制资源,回合父进程共享,像线程,但是会先于父进程运行,并且导致父进程阻塞,直至子进程exit()(不可以使用return,否则会重复进入vfork)<br>clone可以精细控制子进程和父进程的资源共享</p>
<h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p>生成一个只能原子性访问的变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">atomic&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>告知编译器不要从寄存器获取变量的值，而是每次都从内存中载入，避免出现问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">volatile</span> a;</span><br></pre></td></tr></table></figure>

<h2 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h2><p>告知编译器，所有修改该指针指向的值必须通过该指针操作，帮助编译器更好的优化代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *restrict a=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><p>即使结构或类被设置为const,其中某个被mutable修饰的成员也可以被修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> node c;</span><br><span class="line">c.a++; <span class="comment">// 不允许</span></span><br><span class="line">c.b++; <span class="comment">// 允许</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><ul>
<li><code>explicit</code> 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li><code>explicit</code> 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外</li>
</ul>
<h2 id="类型推断和template"><a href="#类型推断和template" class="headerlink" title="类型推断和template"></a>类型推断和template</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T1 a, T1 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显式具体化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">long</span> <span class="title">sum</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sum</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 隐式实例化</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 定义一个和x相同类型的变量y</span></span><br><span class="line"><span class="keyword">decltype</span>(x) y;</span><br><span class="line"><span class="comment">// 返回值类型推断</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(type a)</span> -&gt; <span class="title">decltype</span><span class="params">(a)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="存储方式-访问性"><a href="#存储方式-访问性" class="headerlink" title="存储方式&amp;访问性"></a>存储方式&amp;访问性</h2><table>
<thead>
<tr>
<th>存储描述</th>
<th>持续性</th>
<th>作用域</th>
<th>链接性</th>
<th>声明</th>
</tr>
</thead>
<tbody><tr>
<td>自动</td>
<td>自动</td>
<td>代码块</td>
<td>无</td>
<td>在代码块里</td>
</tr>
<tr>
<td>寄存器</td>
<td>自动</td>
<td>代码块</td>
<td>无</td>
<td>在代码块里,使用<code>register</code></td>
</tr>
<tr>
<td>静态,无链接性</td>
<td>静态</td>
<td>代码块</td>
<td>无</td>
<td>代码块里,使用<code>static</code></td>
</tr>
<tr>
<td>静态,外部链接性</td>
<td>静态</td>
<td>文件</td>
<td>外部</td>
<td>不在任何函数内</td>
</tr>
<tr>
<td>静态,内部链接性</td>
<td>静态</td>
<td>文件</td>
<td>内部</td>
<td>不在任何函数内,使用<code>static</code></td>
</tr>
</tbody></table>
<ul>
<li><p>外部&#x2F;内部链接性区别在于能&#x2F;不能被其他源文件访问</p>
</li>
<li><p>使用<code>extern</code> 声明变量并<strong>不赋值</strong>,则表示此变量在别的文件里,不分配内存</p>
</li>
<li><p>位于文件内,代码块外的<code>const</code>常量,默认是内部链接性的,如果要具有外部链接性,需要<code>extern const</code>定义,并在需要引用的文件中<code>extern const</code>中声明</p>
</li>
<li><p>函数默认是静态外部链接的,加<code>static</code>可以变成内部链接</p>
</li>
<li><p>语言链接性: 编译器可能会在编译时将函数名翻译为另外一种格式,这就可能导致链接错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C++&quot;</span> <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a><strong>attribute</strong></h2><p>__attribute__可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）</p>
<p>packed: 变量或结构域以最小对齐单位对齐，如变量以字节对齐，结构域以位对齐</p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fun(x) #x <span class="comment">// 如果调用fun(abc),则会转为&quot;abc&quot;,即参数的变量名</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fun(x) ahh#x <span class="comment">//fun(abc),abc=1的话,展开为变量:ahh1</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push)  <span class="comment">// 保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)     <span class="comment">// 设定为 4 字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>

<h2 id="拷贝构造函数和赋值运算符"><a href="#拷贝构造函数和赋值运算符" class="headerlink" title="拷贝构造函数和赋值运算符"></a>拷贝构造函数和赋值运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造函数,被赋值对象是新建的</span></span><br><span class="line"><span class="comment">// 在Person a=b;时调用</span></span><br><span class="line"><span class="comment">// 可以写为Person a(b);</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p);</span><br><span class="line"><span class="comment">// 赋值运算符,被赋值的对象是已有的</span></span><br><span class="line"><span class="comment">// 在 Person a; a=b; 时调用</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="comment">// Person b(std::move(a)), b=std::move(a);</span></span><br><span class="line"><span class="built_in">Person</span>(Person&amp;&amp; p);</span><br><span class="line"><span class="comment">// 移动赋值运算符</span></span><br><span class="line"><span class="comment">// Person a,b; a=std::move(b);</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person&amp;&amp; p);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>std::move()转移所有权,被move的元素,会失去对原来值的所有权.(如容器类,则会被清空)</p>
<p>std::forward()直接转发,不修改值的左右值属性</p>
<h2 id="右值引用和转移语义"><a href="#右值引用和转移语义" class="headerlink" title="右值引用和转移语义"></a>右值引用和转移语义</h2><p>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。<br>能够更简洁明确地定义泛型函数</p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond,<span class="type">pthread_condattr_t</span> *cond_attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond,<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_timewait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond,pthread_mutex *mutex,<span class="type">const</span> timespec *abstime)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;  <span class="comment">//解除所有线程的阻塞</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/cpp/" rel="tag"># cpp</a>
              <a href="/tags/programming/" rel="tag"># programming</a>
              <a href="/tags/network/" rel="tag"># network</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/install-wsl-on-a-non-system-drive/" rel="prev" title="install wsl on a non-system drive">
                  <i class="fa fa-angle-left"></i> install wsl on a non-system drive
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/Linux-IPC/" rel="next" title="Linux-IPC">
                  Linux-IPC <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ankikong</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/ankikong" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
